<!doctype html><html lang=ko dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="API composition pattern과 CQRS pattern으로 데이터를 쿼리하는 문제를 해결해 봅니다."><title>마이크로서비스 패턴 7장 마이크로서비스 쿼리 구현</title>
<link rel=canonical href=https://kjs92980.github.io/p/implementing-queries-in-microservice/><link rel=stylesheet href=/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property="og:title" content="마이크로서비스 패턴 7장 마이크로서비스 쿼리 구현"><meta property="og:description" content="API composition pattern과 CQRS pattern으로 데이터를 쿼리하는 문제를 해결해 봅니다."><meta property="og:url" content="https://kjs92980.github.io/p/implementing-queries-in-microservice/"><meta property="og:site_name" content="kjs92980"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2023-07-09T15:46:37+09:00"><meta property="article:modified_time" content="2023-07-09T15:46:37+09:00"><meta property="og:image" content="https://kjs92980.github.io/p/implementing-queries-in-microservice/microservice-patterns.png"><meta name=twitter:title content="마이크로서비스 패턴 7장 마이크로서비스 쿼리 구현"><meta name=twitter:description content="API composition pattern과 CQRS pattern으로 데이터를 쿼리하는 문제를 해결해 봅니다."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kjs92980.github.io/p/implementing-queries-in-microservice/microservice-patterns.png"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/profile_huc4d3543ebe52937477935619fc798777_2053484_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>😪</span></figure><div class=site-meta><h1 class=site-name><a href=/>kjs92980</a></h1><h2 class=site-description>The best way to have a good idea is to have lots of ideas.</h2></div></header><ol class=social-menu><li><a href=https://github.com/kjs92980 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>다크 모드</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#api-composition-pattern>API Composition Pattern</a><ol><li><a href=#overview>Overview</a></li><li><a href=#design-issue>Design Issue</a></li><li><a href=#drawbacks>Drawbacks</a></li></ol></li><li><a href=#cqrs-패턴>CQRS 패턴</a><ol><li><a href=#overview-1>Overview</a></li><li><a href=#benefits>Benefits</a></li><li><a href=#drawbacks-1>Drawbacks</a></li><li><a href=#designing-views>Designing Views</a><ol><li></li></ol></li></ol></li><li><a href=#참조>참조</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/implementing-queries-in-microservice/><img src=/p/implementing-queries-in-microservice/microservice-patterns_hu01dd3f6d24e8ce4d9f2d0e89cd14b66b_971642_800x0_resize_box_3.png srcset="/p/implementing-queries-in-microservice/microservice-patterns_hu01dd3f6d24e8ce4d9f2d0e89cd14b66b_971642_800x0_resize_box_3.png 800w, /p/implementing-queries-in-microservice/microservice-patterns_hu01dd3f6d24e8ce4d9f2d0e89cd14b66b_971642_1600x0_resize_box_3.png 1600w" width=800 height=336 loading=lazy alt="Featured image of post 마이크로서비스 패턴 7장 마이크로서비스 쿼리 구현"></a></div><div class=article-details><header class=article-category><a href=/categories/design-patterns/>Design Patterns</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/implementing-queries-in-microservice/>마이크로서비스 패턴 7장 마이크로서비스 쿼리 구현</a></h2><h3 class=article-subtitle>API composition pattern과 CQRS pattern으로 데이터를 쿼리하는 문제를 해결해 봅니다.</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jul 09, 2023</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>7 분 정도</time></div></footer></div></header><section class=article-content><p>마이크로서비스 패턴 (크리스 리처드슨 저)의 7장 내용을 다룹니다.
마이크로서비스 아키텍처에서 쿼리를 작성할 때는 흩어져 있는 데이터를 검색해야하므로 어려울 수 있습니다.
이 장에서는 마이크로서비스 아키텍처에서 데이터를 쿼리하는 문제를 다음 방법으로 해결해 봅니다.</p><ul><li>API composition pattern API 조합 패턴<ul><li>클라이언트가 각 서비스들을 호출하고 결과를 결합하는 책임을 지는 방식으로 동작합니다.</li></ul></li><li>Command query responsibility segregation 커맨드 쿼리 책임 분산 (CQRS)</li></ul><h2 id=api-composition-pattern>API Composition Pattern</h2><p><img src=/p/implementing-queries-in-microservice/api-composition-pattern1.png width=898 height=657 loading=lazy alt=findOrder() class=gallery-image data-flex-grow=136 data-flex-basis=328px></p><p>모놀리식의 경우(데이터가 단일 데이터베이스에 저장되는 경우) 여러 개의 테이블을 조인하는 select문으로 쉽게 구현할 수 있습니다.<br>하지만 마이크로서비스 기반의 애플리케이션에서는 데이터가 여러 서비스에 흩어져 있습니다. 주문 세부 정보가 필요한 모든 고객은 위 모든 서비스에 요청을 해야합니다.</p><p><img src=/p/implementing-queries-in-microservice/api-composition-pattern2.png width=895 height=541 loading=lazy alt="API composition pattern" class=gallery-image data-flex-grow=165 data-flex-basis=397px></p><p>API composition pattern을 사용하면 이를 쉽게 구현할 수 있습니다.</p><h3 id=overview>Overview</h3><ul><li>API composer<ul><li>클라이언트의 요청을 받아, 여러 Provider Services로부터 필요한 데이터를 가져오는 역할을 합니다.</li><li>이 데이터는 클라이언트가 필요로 하는 형식으로 조합되고, 이 조합된 데이터는 클라이언트에게 응답으로 반환됩니다.</li></ul></li><li>Provider Service<ul><li>API Composer로부터 요청을 받아, 해당 서비스가 가지고 있는 데이터나 기능을 반환하는 역할을 합니다.</li><li>이 서비스들은 독립적으로 운영되며 서로 다른 데이터와 기능을 가질 수 있습니다.</li></ul></li></ul><p>예제에서는 각 Provider service를 REST API 호출을 통해 결과를 가져오고 API composer에서 이를 조인하여 응답합니다.<br>(물론 다른 통신 프로토콜을 사용하는 경우에도 사용할 수 있습니다.)</p><h3 id=design-issue>Design Issue</h3><ol><li>어떤 컴포넌트가 API composer가 될 것인가?</li></ol><ul><li>프론트엔드 클라이언트</li><li>API 게이트웨이<ul><li>API composition 외에도 모든 마이크로 들어오는 요청을 통합적으로 관리하는 역할을 합니다.</li></ul></li><li>독립된 서비스 (stand-alone application)</li></ul><ol start=2><li>어떻게 효과적인 aggregation logic을 작성할지</li></ol><ul><li>느린 aggregation logic은 전체 시스템의 성능을 저하시키고, 클라이언트의 요청을 늦게 처리하는 결과를 초래할 수 있습니다.</li><li>이 과정에서 가능한 한 응답 시간을 최소화하기 위해 Provider services에 동시에 호출을 하는 것이 일반적입니다.</li><li>어떤 Provider service의 경우에는 다른 서비스들로부터의 결과가 필요한 경우가 있을 수 있습니다. 이렇게 병렬로 처리할 부분과 순차적으로 처리할 부분을 조합하는 방식은 복잡성을 증가시킵니다.</li><li>복잡성을 관리하기 위해 API composer은 reactive programming model을 사용하는 것이 좋습니다.</li></ul><h3 id=drawbacks>Drawbacks</h3><p>이 패턴은 마이크로서비스 아키텍처에서 쿼리 작업을 구현하는 간단하고 직관적인 방법이지만, 다음과 같은 단점이 있습니다.</p><ol><li>증가된 오버헤드</li></ol><ul><li>여러 개의 서비스를 호출하고 여러 데이터베이스에 쿼리를 날려야하므로 이로 인한 추가적인 리소스를 필요하게 됩니다.</li></ul><ol start=2><li>Availability 감소의 위험</li></ol><ul><li>API composer와 Provider services가 함께 동작해야하므로 전체 시스템의 가용성이 개인별 서비스 가용성보다 낮아질 수 있습니다. 하나의 서비스가 비정상 상태가 되면 그 서비스를 이용하는 API composition도 영향을 받게 되므로 가용성이 감소하는 문제가 발생할 수 있습니다.</li></ul><p>가용성 감소 문제에 대해 몇 가지 개선 방법을 제시하고 있습니다.</p><ul><li>Provider service가 사용 불가능할 때 이전에 캐시된 데이터를 반환하는 방법입니다. 이 방법을 사용하면 가용성을 향상시킬 수 있지만, 반환된 데이터가 최신 상태가 아닐 수 있다는 문제점이 있습니다.</li><li>API composer가 불완전한 데이터를 반환하는 방법입니다. 일부 서비스가 일시적으로 사용이 불가능하면 해당 데이터를 생략하고 나머지 데이터만 반환하는 것입니다.</li></ul><ol start=3><li>Transactional Data Consistency의 결여</li></ol><ul><li>모놀리식 애플리케이션엥서는 쿼리 연산을 하나의 데이터베이스 트랜잭션으로 실행하는 경우가 많습니다. 이는 일반적으로 애플리케이션에서 데이터의 일관된 뷰를 보장합니다.</li><li>API composition pattern에서는 여러 데이터베이스에 대해 여러 쿼리를 실행합니다. 여기서 일관성이 없는 데이터를 반환하는 문제가 발생할 수 있습니다.</li></ul><p>이 외에도 대량의 데이터셋에 대해 in-memory join을 수행해야하는 경우에는 API composition이 적합하지 않습니다. 메모리에 큰 양의 데이터를 저장하고 데이터를 처리하는데 상당한 리소스를 사용하기 때문에 성능 문제가 발생하거나 시스템이 전체적으로 느려질 수 있습니다.</p><p>API composition pattern의 한계점을 극복하기 위해 CQRS 패턴을 사용할 수 있습니다.</p><h2 id=cqrs-패턴>CQRS 패턴</h2><p>CQRS는 커맨드와 쿼리의 책임을 분리하는 설계 패턴입니다.</p><ul><li>Command: 상태 변경을 요청하는 작업입니다. 새 데이터를 추가하거나 기존 데이터를 업데이트하는 것이 이에 해당합니다.</li><li>Query: 정보를 요청하는 작업입니다. 일반적으로 상태를 변경시키지 않고, 필요한 데이터를 조회하는 것에 해당합니다.</li></ul><h3 id=overview-1>Overview</h3><p>CQRS는 마이크로서비스 아키텍처에서 쿼리를 구현하는 다음 문제들의 해결책이 될 수 있습니다.</p><ol><li>비효율적인 in-memory join</li></ol><ul><li>API composition patern의 in-memory join은 많은 양의 데이터를 처리해야 할 때는 비효율적일 수 있습니다.</li></ul><ol start=2><li>지원하지 않는 데이터베이스나 형식</li></ol><ul><li>서비스가 데이터를 효율적인 쿼리를 지원하지 않는 데이터베이스에 저장하고 있을 수 있습니다. 이는 쿼리를 수행하는데 추가적인 시간이나 리소스를 필요로 할 수 있습니다.</li></ul><ol start=3><li>관심사 분리 원칙</li></ol><ul><li>복잡한 쿼리가 필요한 경우 데이터를 가진 서비스에서 직접 쿼리하는 것이 적합하지 않을 수 있습니다.</li></ul><p><img src=/p/implementing-queries-in-microservice/cqrs1.png width=920 height=643 loading=lazy alt="non-CQRS vs CQRS" class=gallery-image data-flex-grow=143 data-flex-basis=343px></p><ul><li>non-CQRS<ul><li>일반적으로 CRUD 작업이 도메인 모델(데이터베이스에 매핑)을 통해 실행됩니다.</li><li>하나의 데이터 모델이 커맨드(데이터 변경 작업)과 쿼리(데이터 조회 작업)을 모두 지원합니다.</li></ul></li><li>CQRS<ul><li>커맨드와 쿼리로 나뉘며, 커맨드 도메인 모델은 CRUD 작업을 처리하고 별도의 데이터베이스에 매핑이 됩니다. 데이터가 변경될 때마다 도메인 이벤트를 발행합니다.</li><li>쿼리 사이드는 복잡한 쿼리를 처리하는 별도의 모델을 말합니다. 지원하는 쿼리 유형에 가장 적합한 데이터베이스를 사용합니다. 이벤트 핸들러를 가져 커맨드 사이드에서 발행한 이벤트를 구독하고 이에 따라 데이터베이스를 업데이트합니다.</li><li>쿼리 처리 성능을 향상시키는 데 검색 엔진과 같은 도구를 사용할 수 있습니다.</li></ul></li></ul><h3 id=benefits>Benefits</h3><ol><li>마이크로서비스 아키텍처에서의 효율적인 쿼리 구현이 가능합니다.</li></ol><ul><li>기존의 API 조합 패턴에서는 메모리 내에서 데이터를 조인하는데 비효율적일 수 있습니다.</li><li>CQRS는 서비스 간의 데이터를 미리 조인한 형태로 보관하고, 쿼리할 때 이를 활용하여 효율적인 쿼리를 가능하게 합니다.</li></ul><ol start=2><li>다양한 쿼리의 구현이 가능합니다.</li></ol><ul><li>특정 쿼리를 효율적으로 구현하는 하나 이상의 뷰를 정의합니다.</li></ul><ol start=3><li>이벤트 소싱 기반 애플리케이션에서의 쿼리가 가능합니다.</li></ol><ul><li>이벤트 소싱(Event Sourcing)은 상태 변경을 이벤트라는 일련의 변경 로그로 저장하는 방법론입니다. 이벤트 소싱은 시스템의 상태를 변경하는 모든 행동을 이벤트로 캡처하며, 이벤트는 순서대로 저장되고, 이러한 이벤트의 시퀀스로 시스템의 상태를 재현하거나 재생성할 수 있습니다. 이 방법은 비즈니스 요구 사항이 변해도 시스템이 그 변화에 대응할 수 있게 만들어주며, 언제 어떤 이벤트가 발생했는지에 대한 완벽한 기록을 제공합니다.</li><li>그러나 이벤트 소싱의 한계 중 하나는 이벤트 저장소(Event Store)가 기본 키에 기반한 쿼리만 지원한다는 것입니다. 즉, 특정 키를 사용해 직접적인 조회를 할 수 있지만, 그 외의 복잡한 쿼리나 조건을 통한 검색은 어렵습니다.</li><li>CQRS를 이벤트 소싱과 함께 사용하면, 애플리케이션은 &lsquo;Aggregates&rsquo;의 &lsquo;View&rsquo;를 정의하고, 그 뷰는 이벤트 소싱 기반의 집합체가 발행하는 이벤트 스트림을 구독하며 업데이트됩니다. Aggregates는 도메인 모델의 일부를 나타내며, 그 상태는 이벤트를 통해 변경됩니다. 이렇게 만들어진 뷰는 여러 가지 복잡한 쿼리를 처리할 수 있게 해주므로, 이벤트 소싱을 기반으로 한 애플리케이션에서 복잡한 쿼리를 가능하게 합니다.</li></ul><ol start=4><li>관심사의 분리 개선</li></ol><ul><li>CQRS가 하나의 서비스 내에서 &lsquo;커맨드&rsquo;과 &lsquo;쿼리&rsquo;를 처리하는 부분을 분리함으로써 서비스의 복잡성을 줄이고 유지보수를 용이하게 한다는 것을 의미합니다. 예를 들어, 커맨드는 비즈니스 로직을 처리하고 쿼리는 데이터 조회를 처리하게 됩니다. 이렇게 분리함으로써 각 부분은 자신의 역할에만 집중할 수 있게 됩니다.</li></ul><ol start=5><li>데이터를 소유한 서비스와 쿼리를 구현하는 서비스를 분리가 가능합니다.</li></ol><ul><li>CQRS를 이용하면 &lsquo;데이터를 소유하는 서비스&rsquo;와 &lsquo;쿼리를 실행하는 서비스&rsquo;가 서로 다른 서비스로 분리될 수 있다는 것을 의미합니다. 예를 들어, &lsquo;주문 데이터&rsquo;를 소유한 주문 서비스와 주문 조회를 처리하는 주문 조회 서비스가 별도로 존재할 수 있습니다. 이렇게 분리하면 특정 서비스의 부하가 다른 서비스에 영향을 미치는 것을 방지하고, 각 서비스를 독립적으로 확장할 수 있게 됩니다.</li></ul><h3 id=drawbacks-1>Drawbacks</h3><ol><li>아키텍처의 복잡성이 증가합니다.</li></ol><ul><li>데이터를 갱신하고 쿼리하는 쿼리-사이드 서비스를 추가로 구현해야 하며, 이로 인해 추가적인 운영 복잡성이 발생할 수 있습니다.</li><li>여러 타입의 데이터베이스를 사용하게 되어 더 많은 복잡성을 더하게 됩니다.</li></ul><ol start=2><li>커맨드, 쿼리 간의 지연이 있을 수 있습니다.</li></ol><ul><li>커맨드 사이드에서 이벤트를 발행하고 쿼리 사이드에서 이를 처리하여 뷰를 업데이트하는 사이에는 약간의 지연이 있을 수 있습니다.</li><li>불일치를 사용자에게 노출하지 않도록 지연되는 부분을 고려해서 구현해야 합니다.</li></ul><h3 id=designing-views>Designing Views</h3><p><img src=/p/implementing-queries-in-microservice/cqrs2.png width=576 height=456 loading=lazy alt="CQRS view module" class=gallery-image data-flex-grow=126 data-flex-basis=303px></p><h5 id=view-data-store-선택>View Data Store 선택</h5><ul><li>SQL<ul><li>트랜잭션과 쿼리 기능이 잘 구성되어 있으나 데이터 모델이 비교적 유연하지 않아 요구 사항을 만족시키는 데 어려움이 있을 수 있습니다.</li></ul></li><li>NoSQL<ul><li>트랜잭션 및 일반 쿼리 기능이 제한적이지만 CQRS 뷰는 간단한 트랜잭션과 고정된 쿼리만 실행하기 때문에 제한 사항에 크게 영향을 받지 않습니다.</li><li>NoSQL는 유연한 데이터 모델과 더 나은 성능 및 확장성을 강점으로 CQRS 뷰에 적용할 수 있습니다.</li><li>책에 나오는 AWS DynamoDB는 NoSQL 서비스입니다.</li><li>두 개 이상의 서비스가 발행사는 이벤트를 구독하고 그에 따라 뷰를 업데이트해야하는 경우도 있습니다. 이 경우 외래 키를 기반으로 데이터를 업데이트해야 할 수 있습니다. NoSQL의 경우 기본 키를 사용한 연산에 최적화되어 있기 때문에 외래 키 기반의 업데이트를 위한 추가 구현이 필요할 수 있습니다.</li></ul></li></ul><h5 id=data-access-모듈>Data access 모듈</h5><ul><li>동시 업데이트<ul><li>여러 aggregate types에서 발행하는 이벤트를 구독하는 경우, 여러 이벤트 핸들러가 동시에 동일한 레코드를 업데이트할 수 있습니다.</li><li>하나의 업데이트가 다른 업데이트를 덮어쓰는 것을 허용할 수는 없으므로 pessimistic locking 또는 optimistic locking을 사용하여 이를 해결할 수 있습니다.<ul><li>pessimistic locking: 데이터를 읽은 후 변경하기 전에 레코드에 락을 걸어 다른 트랜잭션들이 해당 레코드를 변경할 수 없도록 합니다. 이를 통해 동시에 레코드를 변경하려는 다른 트랜잭션의 개입을 막아 데이터 충돌을 방지합니다.</li><li>optimistic locking: 레코드를 읽을 때 락을 걸지 않습니다. 대신, 레코드를 업데이트하는 시점에 그 레코드가 마지막으로 읽은 이후에 변경되지 않았는지 확인합니다. 이 값이 변경된 경우 충돌이 발생했음을 알리고 해당 트랜잭션을 롤백합니다.</li></ul></li></ul></li><li>멱등성(idempotency)<ul><li>같은 이벤트를 여러 번 받을 수 있는데, 이 경우 일반적으로 쿼리 측 이벤트 핸들러가 멱등하다면 문제가 되지 않습니다.</li><li>이벤트 핸들러가 멱등하지 않는 경우 신뢰성을 유지하기 위해 이벤트 ID를 기록하고 데이터 저장소를 atmoically 업데이트해야 합니다.</li></ul></li><li>최종적 일관성(eventual consistency)<ul><li>불가피한 지연 문제(replication lag)로 클라이언트가 업데이트한 내용을 즉시 쿼리로 볼 수 없는 경우가 있습니다.</li><li>이를 위해 커맨드와 쿼리 모듈은 클라이언트가 불일치를 감지할 수 있도록 지원해야 합니다.</li></ul></li></ul><h5 id=cqrs-뷰-추가-및-업데이트>CQRS 뷰 추가 및 업데이트</h5><p>새로운 쿼리를 지원하기 위해 새로운 뷰를 추가하거나 스키마가 변경되었거나 뷰를 업데이트하는 코드에 버그를 수정해야해서 뷰를 재생성해야 할 때가 있습니다. 이때 다음과 같은 내용을 고려해야 합니다.</p><ul><li>아카이빙된 이벤트를 이용하여 뷰를 구축합니다.<ul><li>메시지 브로커는 메시지를 무기한으로 저장할 수 없습니다. 그 이전의 이벤트도 읽기 위해 메시지 브로커와 별도로 아카이빙된 이벤트를 읽어서 뷰를 구축합니다.</li></ul></li><li>시간이 지남에 따라 점점 모든 이벤트를 처리하는데 비용이 많이 들게 됩니다.<ul><li>two-step incremental algorithm으로 해결할 수 있습니다.<ol><li>Snapshot Creation: 이 단계에서는 각 aggregate instance의 스냅샷을 주기적으로 계산합니다. 이는 이전 스냅샷과 그 이후에 발생한 이벤트를 기반으로 합니다. 이렇게 하면 각 aggregate instance의 상태를 빠르게 알 수 있게 됩니다. 이렇게 생성된 스냅샷은 일종의 체크포인트 역할을 합니다.</li><li>View Building: 이 단계에서는 스냅샷과 그 이후에 발생한 이벤트를 사용하여 뷰를 생성합니다. 이로써 뷰는 최신 상태로 업데이트됩니다.</li></ol></li><li>이 알고리즘의 장점은 모든 이벤트를 처음부터 다시 처리할 필요 없이 뷰를 업데이트할 수 있다는 것입니다. 대신, 가장 최근의 스냅샷에서 시작하여 이후에 발생한 이벤트만 처리하면 됩니다. 이는 뷰를 업데이트하는 데 필요한 시간과 리소스를 크게 줄여줍니다.</li></ul></li></ul><h2 id=참조>참조</h2><ul><li><a class=link href=https://www.yes24.com/Product/Goods/86542732 target=_blank rel=noopener>마이크로서비스 패턴 - 크리스 리처드슨 저</a></li><li><a class=link href=https://microservices.io/patterns/data/api-composition.html target=_blank rel=noopener>Microservice Architecture > Pattern: API Composition</a></li><li><a class=link href=https://microservices.io/patterns/data/cqrs.html target=_blank rel=noopener>Microservice Architecture > Command Query Responsibility Segregation (CQRS)</a></li></ul></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><script src=https://giscus.app/client.js data-repo=kjs92980/comments data-repo-id=R_kgDOIl7l_g data-category=Announcements data-category-id=DIC_kwDOIl7l_s4CTAVg data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark_dimmed")}})()</script><footer class=site-footer><section class=copyright>&copy;
2022 -
2023 kjs92980</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>